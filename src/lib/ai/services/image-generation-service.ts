import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { createOpenAI } from "@ai-sdk/openai";
import { experimental_generateImage as generateImage, generateText } from "ai";
import {
  buildRecipeImagePrompt,
  type ImageGenerationPromptData,
} from "@/lib/ai/prompts/image-generation-prompts";
import type { AIProviderConfig, AIProviderValue } from "@/lib/types";
import { AIProvider } from "@/lib/types";

export interface ImageGenerationResult {
  success: boolean;
  imageData?: string; // base64 encoded
  imageUrl?: string;
  metadata: {
    provider: AIProviderValue;
    model: string;
    prompt: string;
    generatedAt: string;
    size?: string;
    quality?: string;
  };
  error?: string;
}

export async function generateRecipeImage(
  recipeData: ImageGenerationPromptData,
  userConfig: AIProviderConfig,
): Promise<ImageGenerationResult> {
  try {
    // Build comprehensive prompt
    const prompt = buildRecipeImagePrompt(recipeData);

    // Generate image based on provider
    return await callImageGenerationAPI(prompt, userConfig);
  } catch (error) {
    return {
      success: false,
      metadata: {
        provider: userConfig.provider,
        model: "",
        prompt: buildRecipeImagePrompt(recipeData),
        generatedAt: new Date().toISOString(),
      },
      error: error instanceof Error ? error.message : "Unknown error occurred",
    };
  }
}

async function callImageGenerationAPI(
  prompt: string,
  config: AIProviderConfig,
): Promise<ImageGenerationResult> {
  const { provider, apiKey } = config;

  if (!apiKey) {
    throw new Error(`${provider} API key is required for image generation`);
  }

  try {
    let result: { imageData: string } | null = null;
    let modelName: string;

    switch (provider) {
      case AIProvider.GOOGLE: {
        modelName = "gemini-2.5-flash-image-preview";
        // Google uses generateText with image generation model
        const googleClient = createGoogleGenerativeAI({ apiKey });
        const textResult = await generateText({
          model: googleClient(modelName),
          prompt,
        });

        // Find the first image file in the results
        let imageFile = null;
        for (const file of textResult.files || []) {
          if (file.mediaType.startsWith("image/")) {
            imageFile = file;
            break;
          }
        }

        if (!imageFile) {
          throw new Error("No image file generated by Google model");
        }

        // Convert to the expected format
        result = {
          imageData: imageFile.base64,
        };
        break;
      }

      case AIProvider.OPENAI: {
        modelName = "dall-e-3";
        // Create OpenAI client and use image generation
        const openaiClient = createOpenAI({ apiKey });
        const imageResult = await generateImage({
          model: openaiClient.image(modelName),
          prompt,
          size: "1024x1024",
        });
        result = {
          imageData: imageResult.image.base64,
        };
        break;
      }

      default:
        throw new Error(
          `Image generation not supported for provider: ${provider}. Supported providers: Google, OpenAI.`,
        );
    }

    if (!result) {
      throw new Error("Failed to generate image");
    }

    return {
      success: true,
      imageData: result.imageData,
      imageUrl: "", // AI SDK doesn't provide URL, only base64 data
      metadata: {
        provider,
        model: modelName,
        prompt,
        generatedAt: new Date().toISOString(),
        size: "1024x1024",
      },
    };
  } catch (error) {
    throw new Error(
      `Image generation failed: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
}

export function getAvailableImageProviders(userSettings: {
  hasGoogleKey?: boolean;
  hasOpenaiKey?: boolean;
}): AIProviderValue[] {
  const providers: AIProviderValue[] = [];

  // Both Google and OpenAI are supported for image generation
  if (userSettings.hasGoogleKey) {
    providers.push(AIProvider.GOOGLE);
  }

  if (userSettings.hasOpenaiKey) {
    providers.push(AIProvider.OPENAI);
  }

  return providers;
}

export function validateRecipeData(data: ImageGenerationPromptData): string[] {
  const errors: string[] = [];

  if (!data.title?.trim()) {
    errors.push("Recipe title is required for image generation");
    return errors; // Early return if no title
  }

  if (data.title.length > 100) {
    errors.push(
      "Recipe title too long for optimal image generation (max 100 characters)",
    );
  }

  if (!data.ingredients || data.ingredients.length === 0) {
    errors.push("At least one ingredient is required for image generation");
  } else {
    const validIngredients = data.ingredients.filter((ing) => ing.name?.trim());
    if (validIngredients.length === 0) {
      errors.push(
        "At least one ingredient with a name is required for image generation",
      );
    }
  }

  if (!data.instructions || data.instructions.length === 0) {
    errors.push(
      "At least one instruction is recommended for better image generation",
    );
  } else {
    const validInstructions = data.instructions.filter((inst) =>
      inst.instruction?.trim(),
    );
    if (validInstructions.length === 0) {
      errors.push(
        "At least one instruction with content is recommended for better image generation",
      );
    }
  }

  return errors;
}

export function validateImageGenerationConfig(config: unknown): string[] {
  const errors: string[] = [];

  if (!config || typeof config !== "object") {
    errors.push("AI configuration is required");
    return errors;
  }

  const typedConfig = config as Record<string, unknown>;

  if (!typedConfig.provider) {
    errors.push("AI provider is required");
  }

  if (!typedConfig.encryptedApiKey && !typedConfig.apiKey) {
    errors.push("API key is required for image generation");
  }

  const supportedProviders = ["google", "openai"];
  if (
    typedConfig.provider &&
    typeof typedConfig.provider === "string" &&
    !supportedProviders.includes(typedConfig.provider)
  ) {
    errors.push(
      `Provider "${typedConfig.provider}" does not support image generation. Supported providers: ${supportedProviders.join(", ")}`,
    );
  }

  return errors;
}
